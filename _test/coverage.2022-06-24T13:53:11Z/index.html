
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>slaterest: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/happyhippyhippo/slaterest/application.go (34.4%)</option>
				
				<option value="file1">github.com/happyhippyhippo/slaterest/container.go (100.0%)</option>
				
				<option value="file2">github.com/happyhippyhippo/slaterest/errors.go (100.0%)</option>
				
				<option value="file3">github.com/happyhippyhippo/slaterest/srenvelope/container.go (100.0%)</option>
				
				<option value="file4">github.com/happyhippyhippo/slaterest/srenvelope/envelope.go (100.0%)</option>
				
				<option value="file5">github.com/happyhippyhippo/slaterest/srenvelope/errors.go (100.0%)</option>
				
				<option value="file6">github.com/happyhippyhippo/slaterest/srenvelope/list_report.go (100.0%)</option>
				
				<option value="file7">github.com/happyhippyhippo/slaterest/srenvelope/middleware.go (100.0%)</option>
				
				<option value="file8">github.com/happyhippyhippo/slaterest/srenvelope/provider.go (100.0%)</option>
				
				<option value="file9">github.com/happyhippyhippo/slaterest/srenvelope/status.go (100.0%)</option>
				
				<option value="file10">github.com/happyhippyhippo/slaterest/srenvelope/status_error.go (100.0%)</option>
				
				<option value="file11">github.com/happyhippyhippo/slaterest/srenvelope/status_error_list.go (100.0%)</option>
				
				<option value="file12">github.com/happyhippyhippo/slaterest/srlog/container.go (100.0%)</option>
				
				<option value="file13">github.com/happyhippyhippo/slaterest/srlog/errors.go (100.0%)</option>
				
				<option value="file14">github.com/happyhippyhippo/slaterest/srlog/globals.go (100.0%)</option>
				
				<option value="file15">github.com/happyhippyhippo/slaterest/srlog/middleware.go (100.0%)</option>
				
				<option value="file16">github.com/happyhippyhippo/slaterest/srlog/provider.go (100.0%)</option>
				
				<option value="file17">github.com/happyhippyhippo/slaterest/srlog/request_reader_decorator_json.go (100.0%)</option>
				
				<option value="file18">github.com/happyhippyhippo/slaterest/srlog/request_reader_decorator_xml.go (100.0%)</option>
				
				<option value="file19">github.com/happyhippyhippo/slaterest/srlog/request_reader_default.go (100.0%)</option>
				
				<option value="file20">github.com/happyhippyhippo/slaterest/srlog/response_reader_decorator_json.go (100.0%)</option>
				
				<option value="file21">github.com/happyhippyhippo/slaterest/srlog/response_reader_decorator_xml.go (100.0%)</option>
				
				<option value="file22">github.com/happyhippyhippo/slaterest/srlog/response_reader_default.go (100.0%)</option>
				
				<option value="file23">github.com/happyhippyhippo/slaterest/srlog/response_writer.go (100.0%)</option>
				
				<option value="file24">github.com/happyhippyhippo/slaterest/srvalidation/container.go (100.0%)</option>
				
				<option value="file25">github.com/happyhippyhippo/slaterest/srvalidation/errors.go (100.0%)</option>
				
				<option value="file26">github.com/happyhippyhippo/slaterest/srvalidation/parser.go (100.0%)</option>
				
				<option value="file27">github.com/happyhippyhippo/slaterest/srvalidation/provider.go (100.0%)</option>
				
				<option value="file28">github.com/happyhippyhippo/slaterest/srvalidation/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package slaterest

import (
        "fmt"
        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate/sconfig"
        "github.com/happyhippyhippo/slate/sfs"
        "github.com/happyhippyhippo/slate/slog"
        "github.com/happyhippyhippo/slate/smigration"
        "github.com/happyhippyhippo/slate/srdb"
)

// Application defines an object for a slaterest api project.
type Application struct {
        slate.Application
        engine Engine
}

// NewApplication used to instantiate a new application.
func NewApplication() *Application <span class="cov10" title="2">{
        app := &amp;Application{
                Application: *slate.NewApplication(),
                engine:      gin.New(),
        }

        _ = app.Add(sfs.Provider{})
        _ = app.Add(sconfig.Provider{})
        _ = app.Add(slog.Provider{})
        _ = app.Add(srdb.Provider{})
        _ = app.Add(smigration.Provider{})

        _ = app.Container.Service(ContainerEngineID, func() (interface{}, error) </span><span class="cov1" title="1">{
                return app.engine, nil
        }</span>)

        <span class="cov10" title="2">app.engine.Use(
                gin.Recovery(),
                gzip.Gzip(gzip.DefaultCompression),
        )

        return app</span>
}

// Engine returns the reference to the instantiated gin-gonic engine
func (a Application) Engine() Engine <span class="cov1" title="1">{
        return a.engine
}</span>

// Run method will boot the application, if not yet, and the start
// the underlying gin server.
func (a Application) Run(addr ...string) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                err = e
                        }</span> else<span class="cov0" title="0"> {
                                panic(r)</span>
                        }
                }
        }()

        <span class="cov0" title="0">if err := a.Boot(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cfg, err := sconfig.GetConfig(a.Container)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">port, err := cfg.Int(ConfigPortPath, 80)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger, err := slog.GetLogger(a.Container)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_ = logger.Signal(LogChannel, slog.INFO, "App starting", map[string]interface{}{"port": port})
        if err = a.engine.Run(append([]string{fmt.Sprintf(":%d", port)}, addr...)...); err != nil </span><span class="cov0" title="0">{
                _ = logger.Signal(LogChannel, slog.FATAL, "App error", map[string]interface{}{"error": err.Error()})
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package slaterest

import (
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate"
)

// GetEngine will try to retrieve the registered gin engine
// instance from the application service container.
func GetEngine(c slate.ServiceContainer) (*gin.Engine, error) <span class="cov10" title="3">{
        instance, err := c.Get(ContainerEngineID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">i, ok := instance.(*gin.Engine)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "*gin.Engine")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package slaterest

import (
        "fmt"
        "github.com/happyhippyhippo/slate/serror"
)

func errNilPointer(arg string) error <span class="cov1" title="1">{
        return fmt.Errorf("%w : %v", serror.ErrNilPointer, arg)
}</span>

func errConversion(val interface{}, t string) error <span class="cov10" title="2">{
        return fmt.Errorf("%w : %v to %v", serror.ErrConversion, val, t)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package srenvelope

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slaterest"
)

// GetMiddlewareGenerator will try to retrieve the registered logging middleware
// for ok responses instance from the application service container.
func GetMiddlewareGenerator(c slate.ServiceContainer) (func(string) (slaterest.Middleware, error), error) <span class="cov10" title="3">{
        instance, err := c.Get(ContainerID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">i, ok := instance.(func(string) (slaterest.Middleware, error))
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "func(string) (slaterest.Middleware, error)")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package srenvelope

import (
        "encoding/xml"
)

// Envelope identifies the structure of a response structured format.
type Envelope struct {
        XMLName    xml.Name    `json:"-" xml:"envelope"`
        StatusCode int         `json:"-" xml:"-"`
        Status     *Status     `json:"status" xml:"status"`
        Report     *ListReport `json:"report,omitempty" xml:"report,omitempty"`
        Data       interface{} `json:"data,omitempty" xml:"data,omitempty"`
}

// NewEnvelope instantiates a new response data envelope structure
func NewEnvelope(statusCode int, data interface{}, report *ListReport) *Envelope <span class="cov9" title="14">{
        return &amp;Envelope{
                StatusCode: statusCode,
                Status:     NewStatus(),
                Report:     report,
                Data:       data,
        }
}</span>

// GetStatusCode returned the stored enveloped response status code
func (s Envelope) GetStatusCode() int <span class="cov7" title="8">{
        return s.StatusCode
}</span>

// SetService assign the service identifier to all stored error codes
func (s *Envelope) SetService(val int) *Envelope <span class="cov7" title="8">{
        s.Status = s.Status.SetService(val)
        return s
}</span>

// SetEndpoint assign the endpoint identifier to all stored error codes
func (s *Envelope) SetEndpoint(val int) *Envelope <span class="cov7" title="8">{
        s.Status = s.Status.SetEndpoint(val)
        return s
}</span>

// AddError add a new error to the response envelope instance
func (s *Envelope) AddError(err *StatusError) *Envelope <span class="cov10" title="16">{
        s.Status = s.Status.AddError(err)
        return s
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package srenvelope

import (
        "fmt"
        "github.com/happyhippyhippo/slate/serror"
)

func errNilPointer(arg string) error <span class="cov10" title="4">{
        return fmt.Errorf("%w : %v", serror.ErrNilPointer, arg)
}</span>

func errConversion(val interface{}, t string) error <span class="cov5" title="2">{
        return fmt.Errorf("%w : %v to %v", serror.ErrConversion, val, t)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package srenvelope

import (
        "fmt"
)

// ListReport defines the structure of a response list report
// containing all the request information, but also the total amount of
// filtering records and links for the previous and next pages
type ListReport struct {
        Search string `json:"search" xml:"search"`
        Start  uint   `json:"start" xml:"start"`
        Count  uint   `json:"count" xml:"count"`
        Total  uint   `json:"total" xml:"total"`
        Prev   string `json:"prev" xml:"prev"`
        Next   string `json:"next" xml:"next"`
}

// NewListReport instantiates a new response list report by
// populating the prev and next link information regarding the given
// filtering information
func NewListReport(search string, start, count, total uint) *ListReport <span class="cov10" title="8">{
        prev := ""
        if start &gt; 0 </span><span class="cov9" title="7">{
                nstart := uint(0)
                if count &lt; start </span><span class="cov7" title="4">{
                        nstart = start - count
                }</span>
                <span class="cov9" title="7">prev = fmt.Sprintf("?search=%s&amp;start=%d&amp;count=%d", search, nstart, count)</span>
        }

        <span class="cov10" title="8">next := ""
        if start+count &lt; total </span><span class="cov7" title="5">{
                next = fmt.Sprintf("?search=%s&amp;start=%d&amp;count=%d", search, start+count, count)
        }</span>

        <span class="cov10" title="8">return &amp;ListReport{
                Search: search,
                Start:  start,
                Count:  count,
                Total:  total,
                Prev:   prev,
                Next:   next,
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package srenvelope

import (
        "fmt"
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/sconfig"
        "github.com/happyhippyhippo/slaterest"
        "net/http"
)

// NewMiddlewareGenerator returns a middleware generator function
// based on the application configuration. This middleware generator function
// should be called with the corresponding endpoint name, so it can generate
// the appropriate middleware function.
func NewMiddlewareGenerator(cfg sconfig.Manager) (func(string) (slaterest.Middleware, error), error) <span class="cov10" title="15">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("cfg")
        }</span>

        <span class="cov9" title="14">service, err := cfg.Int(ConfigPathServiceID, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="13">_ = cfg.AddObserver(ConfigPathServiceID, func(old interface{}, new interface{}) </span><span class="cov1" title="1">{
                service = new.(int)
        }</span>)

        <span class="cov9" title="13">acceptedList, err := cfg.List(ConfigPathTransportAcceptList)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="12">var accepted []string
        for _, v := range acceptedList </span><span class="cov9" title="12">{
                if tv, ok := v.(string); ok </span><span class="cov9" title="12">{
                        accepted = append(accepted, tv)
                }</span>
        }

        <span class="cov9" title="12">_ = cfg.AddObserver(ConfigPathTransportAcceptList, func(old interface{}, new interface{}) </span><span class="cov1" title="1">{
                accepted = []string{}
                for _, v := range new.([]interface{}) </span><span class="cov1" title="1">{
                        accepted = append(accepted, v.(string))
                }</span>
        })

        <span class="cov9" title="12">return func(id string) (slaterest.Middleware, error) </span><span class="cov8" title="9">{
                endpoint, err := cfg.Int(fmt.Sprintf(ConfigPathEndpointIDFormat, id), 0)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov7" title="8">return func(next gin.HandlerFunc) gin.HandlerFunc </span><span class="cov7" title="8">{
                        return func(ctx *gin.Context) </span><span class="cov7" title="8">{
                                parse := func(val interface{}) </span><span class="cov7" title="7">{
                                        var response *Envelope

                                        switch v := val.(type) </span>{
                                        case *Envelope:<span class="cov1" title="1">
                                                response = v</span>
                                        case error:<span class="cov5" title="4">
                                                response =
                                                        NewEnvelope(http.StatusInternalServerError, nil, nil).
                                                                AddError(NewStatusError(0, v.Error()))</span>
                                        default:<span class="cov3" title="2">
                                                response =
                                                        NewEnvelope(http.StatusInternalServerError, nil, nil).
                                                                AddError(NewStatusError(0, "internal server error"))</span>
                                        }

                                        <span class="cov7" title="7">ctx.Negotiate(
                                                response.GetStatusCode(),
                                                gin.Negotiate{
                                                        Offered: accepted,
                                                        Data:    response.SetService(service).SetEndpoint(endpoint),
                                                },
                                        )</span>
                                }

                                <span class="cov7" title="8">defer func() </span><span class="cov7" title="8">{
                                        if err := recover(); err != nil </span><span class="cov3" title="2">{
                                                parse(err)
                                        }</span>
                                }()

                                <span class="cov7" title="8">next(ctx)

                                if response, exists := ctx.Get("response"); exists </span><span class="cov6" title="5">{
                                        parse(response)
                                }</span>
                        }
                }, nil
        }, nil
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package srenvelope

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate/sconfig"
)

// Provider defines the default envelope provider to be used on
// the application initialization to register the file system adapter service.
type Provider struct{}

var _ slate.ServiceProvider = &amp;Provider{}

// Register will add to the container a new file system adapter instance.
func (p Provider) Register(c slate.ServiceContainer) error <span class="cov10" title="7">{
        if c == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>

        <span class="cov9" title="6">_ = c.Factory(ContainerID, func() (interface{}, error) </span><span class="cov7" title="4">{
                cfg, err := sconfig.GetConfig(c)
                if err != nil </span><span class="cov4" title="2">{
                        return nil, err
                }</span>

                <span class="cov4" title="2">return NewMiddlewareGenerator(cfg)</span>
        })

        <span class="cov9" title="6">return nil</span>
}

// Boot (no-op).
func (Provider) Boot(c slate.ServiceContainer) error <span class="cov4" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package srenvelope

// Status defines the structure to manipulate a
// response status information structure.
type Status struct {
        Success bool            `json:"success" xml:"success"`
        Errors  StatusErrorList `json:"errors" xml:"errors"`
}

// NewStatus instantiates a new request result status structure.
func NewStatus() *Status <span class="cov9" title="19">{
        return &amp;Status{
                Success: true,
                Errors:  StatusErrorList{},
        }
}</span>

// AddError append a new error to the status error list
func (s *Status) AddError(err *StatusError) *Status <span class="cov10" title="26">{
        s.Success = false
        s.Errors = append(s.Errors, err)
        return s
}</span>

// SetService assign a service code to all stored errors.
func (s *Status) SetService(val int) *Status <span class="cov7" title="9">{
        for i := range s.Errors </span><span class="cov7" title="12">{
                s.Errors[i] = s.Errors[i].SetService(val)
        }</span>
        <span class="cov7" title="9">return s</span>
}

// SetEndpoint assign an endpoint code to all stored errors.
func (s *Status) SetEndpoint(val int) *Status <span class="cov7" title="9">{
        for i := range s.Errors </span><span class="cov7" title="12">{
                s.Errors[i] = s.Errors[i].SetEndpoint(val)
        }</span>
        <span class="cov7" title="9">return s</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package srenvelope

import (
        "fmt"
        "strconv"
        "strings"
)

// StatusError defines the structure to manipulate an error structure
// that hold the information of an execution error and be assigned to the
// response status error list.
type StatusError struct {
        Service  int    `json:"-" xml:"-"`
        Endpoint int    `json:"-" xml:"-"`
        Param    int    `json:"-" xml:"-"`
        Error    string `json:"-" xml:"-"`
        Code     string `json:"code" xml:"code"`
        Message  string `json:"message" xml:"message"`
}

// NewStatusError instantiates a new error instance.
func NewStatusError(err any, msg string) *StatusError <span class="cov8" title="42">{
        return (&amp;StatusError{
                Error:   fmt.Sprintf("%v", err),
                Message: msg,
        }).compose()
}</span>

// SetService assigns a service code value to the error.
func (e *StatusError) SetService(val int) *StatusError <span class="cov6" title="20">{
        e.Service = val
        return e.compose()
}</span>

// SetEndpoint assigns an endpoint code value to the error.
func (e *StatusError) SetEndpoint(val int) *StatusError <span class="cov6" title="20">{
        e.Endpoint = val
        return e.compose()
}</span>

// SetParam assigns a parameter code value to the error.
func (e *StatusError) SetParam(param int) *StatusError <span class="cov3" title="4">{
        e.Param = param
        return e.compose()
}</span>

// SetError assigns a error code value to the error.
func (e *StatusError) SetError(err any) *StatusError <span class="cov4" title="5">{
        e.Error = fmt.Sprintf("%v", err)
        return e.compose()
}</span>

// SetMessage assigns a message to the error.
func (e *StatusError) SetMessage(msg string) *StatusError <span class="cov1" title="1">{
        e.Message = msg
        return e
}</span>

// GetCode retrieves the composed code of the error
func (e StatusError) GetCode() string <span class="cov1" title="1">{
        return e.Code
}</span>

// GetMessage retrieves the message associated to the error
func (e StatusError) GetMessage() string <span class="cov1" title="1">{
        return e.Message
}</span>

func (e *StatusError) compose() *StatusError <span class="cov10" title="91">{
        cb := strings.Builder{}

        if e.Service != 0 </span><span class="cov8" title="39">{
                cb.WriteString(fmt.Sprintf("s:%d", e.Service))
        }</span>

        <span class="cov10" title="91">if e.Endpoint != 0 </span><span class="cov7" title="26">{
                if cb.Len() != 0 </span><span class="cov6" title="19">{
                        cb.WriteString(".")
                }</span>
                <span class="cov7" title="26">cb.WriteString(fmt.Sprintf("e:%d", e.Endpoint))</span>
        }

        <span class="cov10" title="91">if e.Param != 0 </span><span class="cov4" title="7">{
                if cb.Len() != 0 </span><span class="cov4" title="6">{
                        cb.WriteString(".")
                }</span>
                <span class="cov4" title="7">cb.WriteString(fmt.Sprintf("p:%d", e.Param))</span>
        }

        <span class="cov10" title="91">if e.Error != "" </span><span class="cov10" title="91">{
                if cb.Len() != 0 </span><span class="cov8" title="47">{
                        cb.WriteString(".")
                }</span>

                <span class="cov10" title="91">if i, err := strconv.Atoi(e.Error); err != nil </span><span class="cov3" title="3">{
                        cb.WriteString(e.Error)
                }</span> else<span class="cov9" title="88"> {
                        cb.WriteString(fmt.Sprintf("c:%d", i))
                }</span>
        }

        <span class="cov10" title="91">e.Code = cb.String()

        return e</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package srenvelope

import (
        "encoding/xml"
)

// StatusErrorList defines a type of data  that holds a list of error structures.
type StatusErrorList []*StatusError

// MarshalXML serialize the error list into a xml string
func (s StatusErrorList) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="4">{
        _ = e.EncodeToken(start)
        for _, v := range s </span><span class="cov10" title="5">{
                name := xml.Name{Space: "", Local: "error"}
                _ = e.EncodeToken(xml.StartElement{
                        Name: name,
                        Attr: []xml.Attr{
                                {Name: xml.Name{Local: "code"}, Value: v.Code},
                                {Name: xml.Name{Local: "message"}, Value: v.Message},
                        },
                })
                _ = e.EncodeToken(xml.EndElement{Name: name})
        }</span>
        <span class="cov8" title="4">_ = e.EncodeToken(xml.EndElement{Name: start.Name})
        _ = e.Flush()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package srlog

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slaterest"
)

// GetMiddlewareOk will try to retrieve the registered logging middleware
// for ok responses instance from the application service container.
func GetMiddlewareOk(c slate.ServiceContainer) (slaterest.Middleware, error) <span class="cov10" title="3">{
        instance, err := c.Get(ContainerOkID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">i, ok := instance.(slaterest.Middleware)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "slaterest.Middleware")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}

// GetMiddlewareCreated will try to retrieve the registered logging middleware
// for created responses instance from the application service container.
func GetMiddlewareCreated(c slate.ServiceContainer) (slaterest.Middleware, error) <span class="cov10" title="3">{
        instance, err := c.Get(ContainerCreatedID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">i, ok := instance.(slaterest.Middleware)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "slaterest.Middleware")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}

// GetMiddlewareNoContent will try to retrieve the registered logging middleware
// for no-content responses instance from the application service container.
func GetMiddlewareNoContent(c slate.ServiceContainer) (slaterest.Middleware, error) <span class="cov10" title="3">{
        instance, err := c.Get(ContainerNoContentID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">i, ok := instance.(slaterest.Middleware)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "slaterest.Middleware")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package srlog

import (
        "fmt"
        "github.com/happyhippyhippo/slate/serror"
)

func errNilPointer(arg string) error <span class="cov10" title="21">{
        return fmt.Errorf("%w : %v", serror.ErrNilPointer, arg)
}</span>

func errConversion(val interface{}, t string) error <span class="cov5" title="4">{
        return fmt.Errorf("%w : %v to %v", serror.ErrConversion, val, t)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package srlog

import (
        "github.com/happyhippyhippo/slate/senv"
        "github.com/happyhippyhippo/slate/slog"
        "github.com/happyhippyhippo/slaterest"
        "strings"
)

const (
        // ContainerID defines the id to be used as the container
        // registration id of a logging middleware instance factory function.
        ContainerID = slaterest.ContainerID + ".log"

        // ContainerOkID defines the id to be used as the
        // container registration id of a standard log middleware generator
        // for a 200(OK) status code.
        ContainerOkID = ContainerID + ".ok"

        // ContainerCreatedID defines the id to be used as
        // the container registration id of a standard log middleware generator
        // for a 201(Created) status code.
        ContainerCreatedID = ContainerID + ".created"

        // ContainerNoContentID defines the id to be used as
        // the container registration id of a standard log middleware generator
        // for a 204(NoContent) status code.
        ContainerNoContentID = ContainerID + ".no_content"
)

const (
        // EnvID defines the slate.slaterest.log package base environment variable name.
        EnvID = slaterest.EnvID + "_LOG"
)

var (
        // RequestChannel defines the channel id to be used when
        // the log middleware sends the request logging signal to the logger
        // instance.
        RequestChannel = senv.String(EnvID+"_REQUEST_CHANNEL", "transport")

        // RequestLevel defines the logging level to be used when
        // the log middleware sends the request logging signal to the logger
        // instance.
        RequestLevel = envToLogLevel(EnvID+"_REQUEST_LEVEL", slog.DEBUG)

        // RequestMessage defines the request event logging message to
        // be used when the log middleware sends the logging signal to the logger
        // instance.
        RequestMessage = senv.String(EnvID+"_REQUEST_MESSAGE", "Request")

        // ResponseChannel defines the channel id to be used when the
        // log middleware sends the response logging signal to the logger instance.
        ResponseChannel = senv.String(EnvID+"_RESPONSE_CHANNEL", "transport")

        // ResponseLevel defines the logging level to be used when the
        // log middleware sends the response logging signal to the logger instance.
        ResponseLevel = envToLogLevel(EnvID+"_RESPONSE_LEVEL", slog.INFO)

        // ResponseMessage defines the response event logging message
        // to be used when the log middleware sends the logging signal to the
        // logger instance.
        ResponseMessage = senv.String(EnvID+"_RESPONSE_MESSAGE", "Response")

        // DecorateJSON flag that defines the decoration of the log entries
        // for JSON body content.
        DecorateJSON = senv.Bool(EnvID+"_DECORATE_JSON", true)

        // DecorateXML flag that defines the decoration of the log entries
        // for XML body content.
        DecorateXML = senv.Bool(EnvID+"_DECORATE_XML", false)
)

func envToLogLevel(env string, def slog.Level) slog.Level <span class="cov10" title="15">{
        v, ok := slog.LevelMap[strings.ToLower(env)]
        if !ok </span><span class="cov4" title="3">{
                return def
        }</span>
        <span class="cov9" title="12">return v</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package srlog

import (
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/slog"
        "github.com/happyhippyhippo/slaterest"
        "time"
)

// NewMiddleware will instantiate a new middleware that will emit
// logging signals on a request event and on a response event.
func NewMiddleware(
        logger *slog.Logger,
        requestReader RequestReader,
        responseReader ResponseReader,
) (slaterest.Middleware, error) <span class="cov10" title="19">{
        if logger == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("logger")
        }</span>
        <span class="cov9" title="18">if requestReader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("requestReader")
        }</span>
        <span class="cov9" title="17">if responseReader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("responseReader")
        }</span>

        <span class="cov9" title="16">return func(next gin.HandlerFunc) gin.HandlerFunc </span><span class="cov1" title="1">{
                return func(ctx *gin.Context) </span><span class="cov1" title="1">{
                        w, _ := newResponseWriter(ctx.Writer)
                        ctx.Writer = w

                        request, _ := requestReader(ctx)
                        _ = logger.Signal(
                                RequestChannel,
                                RequestLevel,
                                RequestMessage,
                                map[string]interface{}{
                                        "request": request,
                                },
                        )

                        startTimestamp := time.Now().UnixMilli()
                        if next != nil </span><span class="cov1" title="1">{
                                next(ctx)
                        }</span>
                        <span class="cov1" title="1">duration := time.Now().UnixMilli() - startTimestamp

                        response, _ := responseReader(ctx, w)
                        _ = logger.Signal(
                                ResponseChannel,
                                ResponseLevel,
                                ResponseMessage,
                                map[string]interface{}{
                                        "request":  request,
                                        "response": response,
                                        "duration": duration,
                                },
                        )</span>
                }
        }, nil
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package srlog

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate/slog"
        "net/http"
)

// Provider defines the gapp-rest-log module service provider to be used on
// the application initialization to register the logging middleware service.
type Provider struct{}

var _ slate.ServiceProvider = &amp;Provider{}

// Register will register the log middleware package instances in the
// application container
func (p Provider) Register(c slate.ServiceContainer) error <span class="cov10" title="21">{
        if c == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>

        <span class="cov9" title="20">createReaders := func(statusCode int) (request RequestReader, response ResponseReader) </span><span class="cov9" title="15">{
                request = RequestReaderDefault
                response = NewResponseReaderDefault(statusCode)

                if DecorateJSON </span><span class="cov7" title="9">{
                        request, _ = NewRequestReaderDecoratorJSON(request, nil)
                        response, _ = NewResponseReaderDecoratorJSON(response, nil)
                }</span>

                <span class="cov9" title="15">if DecorateXML </span><span class="cov6" title="6">{
                        request, _ = NewRequestReaderDecoratorXML(request, nil)
                        response, _ = NewResponseReaderDecoratorXML(response, nil)
                }</span>

                <span class="cov9" title="15">return request, response</span>
        }

        <span class="cov9" title="20">_ = c.Factory(ContainerOkID, func() (interface{}, error) </span><span class="cov6" title="6">{
                logger, err := slog.GetLogger(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov5" title="5">request, response := createReaders(http.StatusOK)

                return NewMiddleware(logger, request, response)</span>
        })

        <span class="cov9" title="20">_ = c.Factory(ContainerCreatedID, func() (interface{}, error) </span><span class="cov6" title="6">{
                logger, err := slog.GetLogger(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov5" title="5">request, response := createReaders(http.StatusCreated)

                return NewMiddleware(logger, request, response)</span>
        })

        <span class="cov9" title="20">_ = c.Factory(ContainerNoContentID, func() (interface{}, error) </span><span class="cov6" title="6">{
                logger, err := slog.GetLogger(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov5" title="5">request, response := createReaders(http.StatusNoContent)

                return NewMiddleware(logger, request, response)</span>
        })

        <span class="cov9" title="20">return nil</span>
}

// Boot will start the migration package
// If the auto migration is defined as true, ether by global variable or
// by environment variable, the migrator will automatically try to migrate
// to the last registered migration
func (p Provider) Boot(c slate.ServiceContainer) error <span class="cov3" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package srlog

import (
        "encoding/json"
        "github.com/gin-gonic/gin"
        "strings"
)

// NewRequestReaderDecoratorJSON will instantiate a new request
// event context reader JSON decorator used to parse the request body as a JSON
// and add the parsed content into the logging data.
func NewRequestReaderDecoratorJSON(reader RequestReader, model interface{}) (RequestReader, error) <span class="cov10" title="16">{
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>

        <span class="cov9" title="15">return func(ctx *gin.Context) (map[string]interface{}, error) </span><span class="cov6" title="6">{
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>

                <span class="cov6" title="5">data, err := reader(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov5" title="4">contentType := strings.ToLower(ctx.Request.Header.Get("Content-Type"))
                if strings.HasPrefix(contentType, gin.MIMEJSON) </span><span class="cov3" title="2">{
                        if err = json.Unmarshal([]byte(data["body"].(string)), &amp;model); err == nil </span><span class="cov1" title="1">{
                                data["bodyJson"] = model
                        }</span>
                }

                <span class="cov5" title="4">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package srlog

import (
        "encoding/xml"
        "github.com/gin-gonic/gin"
        "strings"
)

// NewRequestReaderDecoratorXML will instantiate a new request
// event context reader XML decorator used to parse the request body as an XML
// and add the parsed content into the logging data.
func NewRequestReaderDecoratorXML(reader RequestReader, model interface{}) (RequestReader, error) <span class="cov10" title="14">{
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>

        <span class="cov9" title="13">return func(ctx *gin.Context) (map[string]interface{}, error) </span><span class="cov7" title="7">{
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>

                <span class="cov7" title="6">data, err := reader(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov6" title="5">contentType := strings.ToLower(ctx.Request.Header.Get("Content-Type"))
                if strings.HasPrefix(contentType, gin.MIMEXML) || strings.HasPrefix(contentType, gin.MIMEXML2) </span><span class="cov4" title="3">{
                        if err = xml.Unmarshal([]byte(data["body"].(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                data["bodyXml"] = model
                        }</span>
                }

                <span class="cov6" title="5">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package srlog

import (
        "bytes"
        "github.com/gin-gonic/gin"
        "io"
        "net/http"
)

// RequestReaderDefault is the default function used to parse the request
// context information.
func RequestReaderDefault(ctx *gin.Context) (map[string]interface{}, error) <span class="cov10" title="2">{
        if ctx == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("ctx")
        }</span>

        <span class="cov1" title="1">params := map[string]interface{}{}
        for p, v := range ctx.Request.URL.Query() </span><span class="cov10" title="2">{
                if len(v) == 1 </span><span class="cov1" title="1">{
                        params[p] = v[0]
                }</span> else<span class="cov1" title="1"> {
                        params[p] = v
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "headers": requestHeaders(ctx.Request),
                "method":  ctx.Request.Method,
                "path":    ctx.Request.URL.Path,
                "params":  params,
                "body":    requestBody(ctx.Request),
        }, nil</span>
}

func requestHeaders(request *http.Request) map[string]interface{} <span class="cov1" title="1">{
        headers := map[string]interface{}{}
        for index, header := range request.Header </span><span class="cov10" title="2">{
                if len(header) == 1 </span><span class="cov1" title="1">{
                        headers[index] = header[0]
                }</span> else<span class="cov1" title="1"> {
                        headers[index] = header
                }</span>
        }
        <span class="cov1" title="1">return headers</span>
}

func requestBody(request *http.Request) string <span class="cov1" title="1">{
        var bodyBytes []byte
        if request.Body != nil </span><span class="cov1" title="1">{
                bodyBytes, _ = io.ReadAll(request.Body)
        }</span>
        <span class="cov1" title="1">request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
        return string(bodyBytes)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package srlog

import (
        "encoding/json"
        "github.com/gin-gonic/gin"
        "strings"
)

// NewResponseReaderDecoratorJSON will instantiate a new response
// event context reader JSON decorator used to parse the response   body as
// a JSON and add the parsed content into the logging data.
func NewResponseReaderDecoratorJSON(reader ResponseReader, model interface{}) (ResponseReader, error) <span class="cov10" title="19">{
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>

        <span class="cov9" title="18">return func(ctx *gin.Context, writer responseWriter) (map[string]interface{}, error) </span><span class="cov7" title="9">{
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                <span class="cov7" title="8">if writer == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("writer")
                }</span>

                <span class="cov6" title="7">data, err := reader(ctx, writer)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov6" title="6">if body, ok := data["body"]; ok == true </span><span class="cov5" title="5">{
                        accept := strings.ToLower(ctx.Request.Header.Get("Accept"))
                        if accept == "*/*" || strings.Contains(accept, gin.MIMEJSON) </span><span class="cov4" title="3">{
                                if err = json.Unmarshal([]byte(body.(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                        data["bodyJson"] = model
                                }</span>
                        }
                }

                <span class="cov6" title="6">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package srlog

import (
        "encoding/xml"
        "github.com/gin-gonic/gin"
        "strings"
)

// NewResponseReaderDecoratorXML will instantiate a new response
// event context reader XML decorator used to parse the response body as an XML
// and add the parsed content into the logging data.
func NewResponseReaderDecoratorXML(reader ResponseReader, model interface{}) (ResponseReader, error) <span class="cov10" title="16">{
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>

        <span class="cov9" title="15">return func(ctx *gin.Context, writer responseWriter) (map[string]interface{}, error) </span><span class="cov8" title="9">{
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                <span class="cov7" title="8">if writer == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("writer")
                }</span>

                <span class="cov7" title="7">data, err := reader(ctx, writer)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov6" title="6">if body, ok := data["body"]; ok == true </span><span class="cov6" title="5">{
                        accept := strings.ToLower(ctx.Request.Header.Get("Accept"))
                        if strings.Contains(accept, gin.MIMEXML) || strings.Contains(accept, gin.MIMEXML2) </span><span class="cov4" title="3">{
                                if err = xml.Unmarshal([]byte(body.(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                        data["bodyXml"] = model
                                }</span>
                        }
                }

                <span class="cov6" title="6">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package srlog

import "github.com/gin-gonic/gin"

// NewResponseReaderDefault generates a new default response reader with
// the defined expected status code.
func NewResponseReaderDefault(statusCode int) ResponseReader <span class="cov10" title="20">{
        return func(_ *gin.Context, writer responseWriter) (map[string]interface{}, error) </span><span class="cov4" title="3">{
                if writer == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("writer")
                }</span>

                <span class="cov3" title="2">status := writer.Status()
                data := map[string]interface{}{
                        "status":  status,
                        "headers": responseHeaders(writer),
                }

                if status != statusCode </span><span class="cov1" title="1">{
                        data["body"] = string(writer.Body())
                }</span>

                <span class="cov3" title="2">return data, nil</span>
        }
}

func responseHeaders(response responseWriter) map[string]interface{} <span class="cov3" title="2">{
        headers := map[string]interface{}{}
        for index, header := range response.Header() </span><span class="cov5" title="4">{
                if len(header) == 1 </span><span class="cov3" title="2">{
                        headers[index] = header[0]
                }</span> else<span class="cov3" title="2"> {
                        headers[index] = header
                }</span>
        }
        <span class="cov3" title="2">return headers</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package srlog

import (
        "bytes"
        "github.com/gin-gonic/gin"
)

type responseWriter interface {
        gin.ResponseWriter
        Body() []byte
}

type writer struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

var _ gin.ResponseWriter = &amp;writer{}

func newResponseWriter(w gin.ResponseWriter) (responseWriter, error) <span class="cov10" title="19">{
        if w == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("writer")
        }</span>

        <span class="cov9" title="18">return &amp;writer{
                ResponseWriter: w,
                body:           &amp;bytes.Buffer{},
        }, nil</span>
}

// Write executes the writing the desired bytes into the underlying writer
// and storing them in the internal buffer.
func (w writer) Write(b []byte) (int, error) <span class="cov1" title="1">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

// Body will retrieve the stored bytes given on the previous calls
// to the Write method.
func (w writer) Body() []byte <span class="cov3" title="2">{
        return w.body.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package srvalidation

import (
        ut "github.com/go-playground/universal-translator"
        "github.com/happyhippyhippo/slate"
)

// GetUniversalTranslator will try to retrieve the registered universal translator
// instance from the application service container.
func GetUniversalTranslator(c slate.ServiceContainer) (*ut.UniversalTranslator, error) <span class="cov10" title="15">{
        instance, err := c.Get(ContainerUniversalTranslatorID)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="13">i, ok := instance.(*ut.UniversalTranslator)
        if !ok </span><span class="cov3" title="2">{
                return nil, errConversion(instance, "*ut.UniversalTranslator")
        }</span>
        <span class="cov8" title="11">return i, nil</span>
}

// GetTranslator will try to retrieve the registered translator
// instance from the application service container.
func GetTranslator(c slate.ServiceContainer) (ut.Translator, error) <span class="cov9" title="12">{
        instance, err := c.Get(ContainerTranslatorID)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov8" title="9">i, ok := instance.(ut.Translator)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "ut.Translator")
        }</span>
        <span class="cov7" title="8">return i, nil</span>
}

// GetParser will try to retrieve the registered error perser
// instance from the application service container.
func GetParser(c slate.ServiceContainer) (Parser, error) <span class="cov6" title="6">{
        instance, err := c.Get(ContainerParserID)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="4">i, ok := instance.(Parser)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "Parser")
        }</span>
        <span class="cov4" title="3">return i, nil</span>
}

// GetValidator will try to retrieve the registered validator
// instance from the application service container.
func GetValidator(c slate.ServiceContainer) (Validator, error) <span class="cov4" title="3">{
        instance, err := c.Get(ContainerID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">i, ok := instance.(Validator)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(instance, "Validator")
        }</span>
        <span class="cov1" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package srvalidation

import (
        "fmt"
        "github.com/happyhippyhippo/slate/serror"
)

func errNilPointer(arg string) error <span class="cov10" title="12">{
        return fmt.Errorf("%w : %v", serror.ErrNilPointer, arg)
}</span>

func errConversion(val interface{}, t string) error <span class="cov8" title="7">{
        return fmt.Errorf("%w : %v to %v", serror.ErrConversion, val, t)
}</span>

func errTranslatorNotFound(translator string) error <span class="cov8" title="7">{
        return fmt.Errorf("%w : %v", serror.ErrTranslatorNotFound, translator)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package srvalidation

import (
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        "github.com/happyhippyhippo/slaterest/srenvelope"
        "net/http"
        "reflect"
        "strconv"
)

// Parser defines the interface to an error parsing object used to
// convert a validation error into an envelope error
type Parser interface {
        Parse(val interface{}, errs validator.ValidationErrors) (*srenvelope.Envelope, error)
        AddError(err string, code int)
}

type parser struct {
        mapper     map[string]int
        translator ut.Translator
}

var _ Parser = &amp;parser{}

// NewParser instantiate a new validation parser instance
func NewParser(translator ut.Translator) (Parser, error) <span class="cov10" title="15">{
        if translator == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("translator")
        }</span>

        <span class="cov9" title="14">return &amp;parser{
                mapper: map[string]int{
                        "eqcsfield":     1,
                        "eqfield":       2,
                        "fieldcontains": 3,
                        "fieldexcludes": 4,
                        "gtcsfield":     5,
                        "gtecsfield":    6,
                        "gtefield":      7,
                        "gtfield":       8,
                        "ltcsfield":     9,
                        "ltecsfield":    10,
                        "ltefield":      11,
                        "ltfield":       12,
                        "necsfield":     13,
                        "nefield":       14,

                        "cidr":             15,
                        "cidrv4":           16,
                        "cidrv6":           17,
                        "datauri":          18,
                        "fqdn":             19,
                        "hostname":         20,
                        "hostname_port":    21,
                        "hostname_rfc1123": 22,
                        "ip":               23,
                        "ip4_addr":         24,
                        "ip6_addr":         25,
                        "ip_addr":          26,
                        "ipv4":             27,
                        "ipv6":             28,
                        "mac":              29,
                        "tcp4_addr":        30,
                        "tcp6_addr":        31,
                        "tcp_addr":         32,
                        "udp4_addr":        33,
                        "udp6_addr":        34,
                        "udp_addr":         35,
                        "unix_addr":        36,
                        "uri":              37,
                        "url":              38,
                        "url_encoded":      39,
                        "urn_rfc2141":      40,

                        "alpha":           41,
                        "alphanum":        42,
                        "alphanumunicode": 43,
                        "alphaunicode":    44,
                        "ascii":           45,
                        "contains":        46,
                        "containsany":     47,
                        "containsrune":    48,
                        "endswith":        49,
                        "lowercase":       50,
                        "multibyte":       51,
                        "number":          52,
                        "numeric":         53,
                        "printascii":      54,
                        "startswith":      55,
                        "uppercase":       56,

                        "base64":          57,
                        "base64url":       58,
                        "btc_addr":        59,
                        "btc_addr_bech32": 60,
                        "datetime":        61,
                        "e164":            62,
                        "email":           63,
                        "eth_addr":        64,
                        "hexadecimal":     65,
                        "hexcolor":        66,
                        "hsl":             67,
                        "hsla":            68,
                        "html":            69,
                        "html_encoded":    70,
                        "isbn":            71,
                        "isbn10":          72,
                        "isbn13":          73,
                        "json":            74,
                        "latitude":        75,
                        "longitude":       76,
                        "rgb":             77,
                        "rgba":            78,
                        "ssn":             79,
                        "uuid":            80,
                        "uuid3":           81,
                        "uuid3_rfc4122":   82,
                        "uuid4":           83,
                        "uuid4_rfc4122":   84,
                        "uuid5":           85,
                        "uuid5_rfc4122":   86,
                        "uuid_rfc4122":    87,

                        "eq":  88,
                        "gt":  89,
                        "gte": 90,
                        "lt":  91,
                        "lte": 92,
                        "ne":  93,

                        "dir":                  94,
                        "excludes":             95,
                        "excludesall":          96,
                        "excludesrune":         97,
                        "file":                 98,
                        "isdefault":            99,
                        "len":                  100,
                        "max":                  101,
                        "min":                  102,
                        "oneof":                103,
                        "required":             104,
                        "required_if":          105,
                        "required_unless":      106,
                        "required_with":        107,
                        "required_with_all":    108,
                        "required_without":     109,
                        "required_without_all": 110,
                        "excluded_with":        111,
                        "excluded_with_all":    112,
                        "excluded_without":     113,
                        "excluded_without_all": 114,
                        "unique":               115,
                },
                translator: translator,
        }, nil</span>
}

// Parse method that will convert the list of validation errors into
// an envelope struct to be used as the endpoint response.
func (p parser) Parse(val interface{}, errs validator.ValidationErrors) (*srenvelope.Envelope, error) <span class="cov8" title="9">{
        if val == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("value")
        }</span>

        <span class="cov7" title="8">if errs == nil || len(errs) == 0 </span><span class="cov3" title="2">{
                return nil, nil
        }</span>

        <span class="cov6" title="6">resp := srenvelope.NewEnvelope(http.StatusBadRequest, nil, nil)
        for _, err := range errs </span><span class="cov6" title="6">{
                parsed, result := p.convert(val, err)
                if result != nil </span><span class="cov3" title="2">{
                        return nil, result
                }</span>
                <span class="cov5" title="4">resp = resp.AddError(parsed)</span>
        }

        <span class="cov5" title="4">return resp, nil</span>
}

// AddError will add a validation mapped error to code value.
func (p *parser) AddError(err string, code int) <span class="cov1" title="1">{
        p.mapper[err] = code
}</span>

func (p parser) convert(value interface{}, err validator.FieldError) (*srenvelope.StatusError, error) <span class="cov6" title="6">{
        if err == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("err")
        }</span>

        <span class="cov6" title="5">typeof := reflect.TypeOf(value)
        field, _ := typeof.FieldByName(err.StructField())
        iparam := 0
        if param, ok := field.Tag.Lookup("vparam"); ok </span><span class="cov3" title="2">{
                var err error
                if iparam, err = strconv.Atoi(param); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="4">return srenvelope.NewStatusError(p.mapper[err.Tag()], err.Translate(p.translator)).SetParam(iparam), nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package srvalidation

import (
        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        translations "github.com/go-playground/validator/v10/translations/en"
        "github.com/happyhippyhippo/slate"
)

// Provider @todo doc
type Provider struct{}

var _ slate.ServiceProvider = &amp;Provider{}

// Register will register the validation package instances in the
// application container
func (p Provider) Register(c slate.ServiceContainer) error <span class="cov10" title="19">{
        if c == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>

        <span class="cov9" title="17">_ = c.Service(ContainerUniversalTranslatorID, func() (interface{}, error) </span><span class="cov8" title="12">{
                lang := en.New()
                return ut.New(lang, lang), nil
        }</span>)

        <span class="cov9" title="17">_ = c.Service(ContainerTranslatorID, func() (interface{}, error) </span><span class="cov8" title="12">{
                universalTranslator, err := GetUniversalTranslator(c)
                if err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>

                <span class="cov8" title="10">translator, found := universalTranslator.GetTranslator(Locale)
                if found == false </span><span class="cov4" title="3">{
                        return nil, errTranslatorNotFound(Locale)
                }</span>

                <span class="cov6" title="7">return translator, nil</span>
        })

        <span class="cov9" title="17">_ = c.Service(ContainerParserID, func() (interface{}, error) </span><span class="cov5" title="5">{
                translator, err := GetTranslator(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov5" title="4">return NewParser(translator)</span>
        })

        <span class="cov9" title="17">_ = c.Service(ContainerID, func() (interface{}, error) </span><span class="cov5" title="4">{
                translator, err := GetTranslator(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov4" title="3">parser, err := GetParser(c)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov3" title="2">validate := validator.New()
                _ = translations.RegisterDefaultTranslations(validate, translator)

                return NewValidator(validate, parser)</span>
        })

        <span class="cov9" title="17">return nil</span>
}

// Boot will start the validation package
func (Provider) Boot(c slate.ServiceContainer) error <span class="cov3" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package srvalidation

import (
        "github.com/go-playground/validator/v10"
        "github.com/happyhippyhippo/slaterest/srenvelope"
)

// Validator is a function type used to define a calling interface of
// function responsible to validate an instance of a structure and return
// an initialized response envelope with the founded errors
type Validator func(val interface{}) (*srenvelope.Envelope, error)

// NewValidator instantiates a new validation function
func NewValidator(validate *validator.Validate, parser Parser) (Validator, error) <span class="cov10" title="9">{
        if validate == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("validate")
        }</span>
        <span class="cov9" title="8">if parser == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("parser")
        }</span>

        <span class="cov8" title="7">return func(value interface{}) (*srenvelope.Envelope, error) </span><span class="cov6" title="4">{
                if value == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("value")
                }</span>

                <span class="cov5" title="3">if errs := validate.Struct(value); errs != nil </span><span class="cov3" title="2">{
                        return parser.Parse(value, errs.(validator.ValidationErrors))
                }</span>

                <span class="cov1" title="1">return nil, nil</span>
        }, nil
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
